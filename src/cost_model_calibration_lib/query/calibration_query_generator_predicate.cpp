#include "calibration_query_generator_predicate.hpp"

#include <random>

#include "constant_mappings.hpp"
#include "expression/expression_functional.hpp"
#include "expression/expression_utils.hpp"
#include "logical_query_plan/stored_table_node.hpp"
#include "logical_query_plan/validate_node.hpp"
#include "storage/storage_manager.hpp"

using namespace opossum::expression_functional;  // NOLINT

namespace opossum {

const std::vector<CalibrationQueryGeneratorPredicateConfiguration>
CalibrationQueryGeneratorPredicate::generate_predicate_permutations(
    const std::vector<std::pair<std::string, size_t>>& tables, const CalibrationConfiguration& configuration) {
  std::vector<CalibrationQueryGeneratorPredicateConfiguration> output{};

  // Wrap all encoding in std::optional and add std::nullopt. Used for second and third column encodings
  std::vector<std::optional<EncodingType>> all_encodings;
  for (const auto& encoding : configuration.encodings) {
    all_encodings.emplace_back(encoding);
  }
  all_encodings.push_back({});

  // Generating all combinations
  for (const auto& data_type : configuration.data_types) {
    for (const auto& first_encoding : configuration.encodings) {
        // Illegal data type - encoding combinations
      if (data_type != DataType::String && first_encoding == EncodingType::FixedStringDictionary) continue;
      if (data_type != DataType::Int && data_type != DataType::Long && first_encoding == EncodingType::FrameOfReference) {
        continue;
      }
      for (const auto& second_encoding : all_encodings) {
          // Illegal data type - encoding combination
        if (second_encoding && data_type != DataType::String && second_encoding == EncodingType::FixedStringDictionary) {
          continue;
        }
          // Illegal data type - encoding combination
        if (second_encoding && data_type != DataType::Int && data_type != DataType::Long && second_encoding == EncodingType::FrameOfReference) {
          continue;
        }
        for (const auto& third_encoding : all_encodings) {
            // Cannot generate queries without second_encoding but with third_encoding
            if (!second_encoding && third_encoding) {
                continue;
            }
            // Illegal data type - encoding combination
          if (third_encoding && data_type != DataType::String &&
              third_encoding == EncodingType::FixedStringDictionary) {
            continue;
          }
            // Illegal data type - encoding combination
          if (third_encoding && data_type != DataType::Int && data_type != DataType::Long &&
              third_encoding == EncodingType::FrameOfReference) {
            continue;
          }

          // If we have a column-to-column scan, we don't need the selectivity..
          // effectively reducing the number of generated queries
          if (second_encoding) {
            for (const auto& table : tables) {
              // With and without ReferenceSegments
              output.push_back({table.first, data_type, first_encoding, second_encoding, third_encoding, 0.5,
                                false, table.second});
              output.push_back({table.first, data_type, first_encoding, second_encoding, third_encoding, 0.5,
                                true, table.second});
            }
          } else {
            for (const auto& selectivity : configuration.selectivities) {
              for (const auto& table : tables) {
                // With and without ReferenceSegments
                output.push_back({table.first, data_type, first_encoding, second_encoding, third_encoding, selectivity,
                                  false, table.second});
                output.push_back({table.first, data_type, first_encoding, second_encoding, third_encoding, selectivity,
                                  true, table.second});
              }
            }
          }
        }
      }
    }
  }

  std::cout << "Generated " << output.size() << " Permutations for Predicates" << std::endl;
  return output;
}

/**
 * Generates a list of predicates that are generated by the predicate_generator,
 * e.g., an IndexScan-based and a TableScan-based variant,
 * but also permutations for different secondary columns in cases with column-to-columns scans.
*/
const std::vector<std::shared_ptr<PredicateNode>> CalibrationQueryGeneratorPredicate::generate_predicates(
    const PredicateGeneratorFunctor& predicate_generator,
    const std::vector<CalibrationColumnSpecification>& column_definitions,
    const std::shared_ptr<StoredTableNode>& table, const CalibrationQueryGeneratorPredicateConfiguration& configuration,
    const bool generate_index_scan) {
  auto predicate = predicate_generator({table, column_definitions, configuration});

  // TODO(Sven): add test for this case
  if (!predicate) {
    std::cout << "missing predicate for configuration " << configuration << std::endl;
    return {};
  }

  std::vector<ScanType> scan_types = {ScanType::TableScan, ScanType ::IndexScan};
  std::vector<std::shared_ptr<PredicateNode>> permutated_predicate_nodes{};

  for (const auto& scan_type : scan_types) {
    // IndexScans support less options than TableScans.. let's filter here
    if (scan_type == ScanType::IndexScan) {
      if (!generate_index_scan) continue;

      auto column_expression_count = 0;
      visit_expression(predicate, [&](const auto& sub_expression) {
        if (sub_expression->type == ExpressionType::LQPColumn) {
          column_expression_count += 1;
        }

        return ExpressionVisitation::VisitArguments;
      });

      // IndexScan neither works on ReferenceSegments nor handles multiple columns in B-Tree
      if (configuration.reference_column || column_expression_count > 1) continue;

      //      if (predicate->type != ExpressionType::Predicate) {
      //        std::cout << "Is this really supported? IndexScan with ExpressionType::"
      //                  << expression_type_to_string.at(predicate->type) << std::endl;
      //      }

      if (predicate->type == ExpressionType::Predicate) {
        const auto abstract_predicate_expression = std::dynamic_pointer_cast<AbstractPredicateExpression>(predicate);
        // IndexScans do not support Like or NotLike predicates
        const auto predicate_condition = abstract_predicate_expression->predicate_condition;
        if (predicate_condition == PredicateCondition::Like || predicate_condition == PredicateCondition::NotLike) {
          continue;
        }
      }
    }
    const auto predicate_node = PredicateNode::make(predicate);
    predicate_node->scan_type = scan_type;
    permutated_predicate_nodes.push_back(predicate_node);
  }

  return permutated_predicate_nodes;
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_between_value_value(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;
  const auto table = generator_configuration.table;

  const auto scan_column_configuration = _find_column_for_configuration(
      generator_configuration.column_definitions, calibration_config.data_type, calibration_config.first_encoding_type);

  if (!scan_column_configuration) {
    std::cout << "BetweenValueValue: Did not find query for configuration " << calibration_config << std::endl;
    return {};
  }

  const auto scan_column = _generate_column_expression(table, *scan_column_configuration);
  const auto first_value = _generate_value_expression(calibration_config.data_type, calibration_config.selectivity);
  const auto second_value = _generate_value_expression(calibration_config.data_type, 0.0f);

  if (first_value->value < second_value->value) {
    return between_(scan_column, first_value, second_value);
  }
  return between_(scan_column, second_value, first_value);
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_between_column_column(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;

  const auto second_encoding_type = calibration_config.second_encoding_type;
  Assert(second_encoding_type, "BetweenColumnColumn needs second encoding");
  const auto third_encoding_type = calibration_config.third_encoding_type;
  Assert(third_encoding_type, "BetweenColumnColumn needs third encoding");

  const auto table = generator_configuration.table;
  auto remaining_columns = generator_configuration.column_definitions;

  const auto scan_column_configuration = _find_column_for_configuration(remaining_columns, calibration_config.data_type,
                                                                        calibration_config.first_encoding_type);

  DebugAssert(scan_column_configuration, "BetweenColumnColumn::Did not find scan_column_configuration");

  remaining_columns.erase(std::remove(remaining_columns.begin(), remaining_columns.end(), scan_column_configuration),
                          remaining_columns.end());

  const auto second_column_configuration =
      _find_column_for_configuration(remaining_columns, calibration_config.data_type, *second_encoding_type);

  DebugAssert(second_column_configuration, "BetweenColumnColumn::Did not find first_column_configuration");

  remaining_columns.erase(std::remove(remaining_columns.begin(), remaining_columns.end(), second_column_configuration),
                          remaining_columns.end());

  const auto third_column_configuration =
      _find_column_for_configuration(remaining_columns, calibration_config.data_type, *third_encoding_type);

  DebugAssert(third_column_configuration, "BetweenColumnColumn::Did not find second_column_configuration");

  if (!scan_column_configuration || !second_column_configuration || !third_column_configuration) {
    std::cout << "BetweenColumnColumn: Did not find query for configuration " << calibration_config << std::endl;
    return {};
  }

  const auto scan_column = _generate_column_expression(table, *scan_column_configuration);
  const auto second_value = _generate_column_expression(table, *second_column_configuration);
  const auto third_value = _generate_column_expression(table, *third_column_configuration);

  return between_(scan_column, second_value, third_value);
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_column_value(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;

  const auto table = generator_configuration.table;
  const auto filter_column_configuration = _find_column_for_configuration(
      generator_configuration.column_definitions, calibration_config.data_type, calibration_config.first_encoding_type);

  if (!filter_column_configuration) {
    std::cout << "ColumnValue: Did not find query for configuration " << calibration_config << std::endl;
    return {};
  }

  const auto filter_column = _generate_column_expression(table, *filter_column_configuration);
  const auto value = _generate_value_expression(calibration_config.data_type, calibration_config.selectivity);
  return less_than_equals_(filter_column, value);
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_column_column(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;

  const auto second_encoding_type = calibration_config.second_encoding_type;
  Assert(second_encoding_type, "BetweenColumnColumn needs second encoding");

  auto remaining_columns = generator_configuration.column_definitions;

  const auto table = generator_configuration.table;
  const auto first_column_configuration = _find_column_for_configuration(
      remaining_columns, calibration_config.data_type, calibration_config.first_encoding_type);

  remaining_columns.erase(std::remove(remaining_columns.begin(), remaining_columns.end(), first_column_configuration),
                          remaining_columns.end());

  const auto second_column_configuration =
      _find_column_for_configuration(remaining_columns, calibration_config.data_type, *second_encoding_type);

  if (!first_column_configuration || !second_column_configuration) {
    std::cout << "ColumnColumn: Did not find query for configuration " << calibration_config << std::endl;
    return {};
  }

  const auto first_column = _generate_column_expression(table, *first_column_configuration);
  const auto second_column = _generate_column_expression(table, *second_column_configuration);

  return less_than_equals_(first_column, second_column);
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_like(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;

  if (calibration_config.data_type != DataType::String) {
    std::cout << "Like: trying to generate for non-string column" << std::endl;
    return {};
  };

  const auto table = generator_configuration.table;
  const auto filter_column_configuration = _find_column_for_configuration(
      generator_configuration.column_definitions, calibration_config.data_type, calibration_config.first_encoding_type);

  if (!filter_column_configuration) {
    std::cout << "Like: Did not find query for configuration " << calibration_config << std::endl;
    return {};
  }

  const auto filter_column = _generate_column_expression(table, *filter_column_configuration);
  const auto value = _generate_value_expression(calibration_config.data_type, calibration_config.selectivity, true);

  return like_(filter_column, value);
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_equi_on_strings(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;

  if (calibration_config.data_type != DataType::String) {
    std::cout << "EquiString: trying to generate for non-string column" << std::endl;
    return {};
  };

  const auto table = generator_configuration.table;
  const auto filter_column_configuration = _find_column_for_configuration(
      generator_configuration.column_definitions, calibration_config.data_type, calibration_config.first_encoding_type);

  if (!filter_column_configuration) {
    std::cout << "EquiString: Did not find query for configuration " << calibration_config << std::endl;
    return {};
  }

  const auto filter_column = _generate_column_expression(table, *filter_column_configuration);
  const auto column_id = filter_column->column_reference.original_column_id();

  // Get an existing value from column and filter by that
  static std::mt19937 engine((std::random_device()()));
  const auto stored_table = StorageManager::get().get_table(table->table_name);
  std::uniform_int_distribution<uint64_t> row_id_dist(0, stored_table->row_count() - 1);
  const auto row_id = row_id_dist(engine);
  const auto value = stored_table->get_value<pmr_string>(column_id, row_id);

  return equals_(filter_column, value);
}

const std::shared_ptr<AbstractExpression> CalibrationQueryGeneratorPredicate::generate_predicate_or(
    const PredicateGeneratorFunctorConfiguration& generator_configuration) {
  const auto calibration_config = generator_configuration.configuration;

  const CalibrationQueryGeneratorPredicateConfiguration second_configuration{
      calibration_config.table_name,          calibration_config.data_type,
      calibration_config.first_encoding_type, calibration_config.second_encoding_type,
      calibration_config.third_encoding_type, 0.5f,
      calibration_config.reference_column,    calibration_config.row_count};

  const auto lhs = generate_predicate_column_value(
      {generator_configuration.table, generator_configuration.column_definitions, calibration_config});
  const auto rhs = generate_predicate_column_value(
      {generator_configuration.table, generator_configuration.column_definitions, second_configuration});

  if (!lhs || !rhs) {
    std::cout << "Or: Did not find query for configuration " << calibration_config << std::endl;
    return {};
  }

  return or_(lhs, rhs);
}

/**
 *
 * @param column_definitions
 * @param data_type
 * @param encoding_type
 * @return
 */
const std::optional<CalibrationColumnSpecification> CalibrationQueryGeneratorPredicate::_find_column_for_configuration(
    const std::vector<CalibrationColumnSpecification>& column_definitions, const DataType& data_type,
    const EncodingType& encoding_type) {
  for (const auto& definition : column_definitions) {
    if (definition.type == data_type && definition.encoding == encoding_type) {
      return definition;
    }
  }

  return {};
}

const std::shared_ptr<LQPColumnExpression> CalibrationQueryGeneratorPredicate::_generate_column_expression(
    const std::shared_ptr<StoredTableNode>& table, const CalibrationColumnSpecification& filter_column) {
  const auto column_name = filter_column.column_name;
  const auto lqp_column_reference = table->get_column(column_name);
  return lqp_column_(lqp_column_reference);
}

const std::shared_ptr<ValueExpression> CalibrationQueryGeneratorPredicate::_generate_value_expression(
    const DataType& data_type, const float selectivity, const bool trailing_like) {
  const auto int_value_upper_limit = 10000000;

  const auto int_value = static_cast<int>(int_value_upper_limit * selectivity);
  const auto float_value = selectivity;
  const auto string_value = static_cast<int>(25 * selectivity);

  switch (data_type) {
    case DataType::Int:
    case DataType::Long:
      return value_(int_value);
    case DataType::String: {
      const auto character = pmr_string(1, static_cast<char>('A' + string_value));
      if (trailing_like) {
        return value_(character + '%');
      }
      return value_(character);
    }
    case DataType::Float:
    case DataType::Double:
      return value_(float_value);
    case DataType::Bool:
    case DataType::Null:
    default:
      Fail("Unsupported data type in CalibrationQueryGeneratorPredicates, found " +
           data_type_to_string.left.at(data_type));
  }
}

}  // namespace opossum
